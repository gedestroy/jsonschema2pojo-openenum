package org.swisspush.jsonschema2pojo.openenum;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.sun.codemodel.*;
import org.jsonschema2pojo.Schema;
import org.jsonschema2pojo.exception.ClassAlreadyExistsException;
import org.jsonschema2pojo.exception.GenerationException;
import org.jsonschema2pojo.rules.Rule;
import org.jsonschema2pojo.rules.RuleFactory;

import java.util.*;

import static java.util.Arrays.asList;
import static org.apache.commons.lang.WordUtils.capitalize;
import static org.apache.commons.lang3.StringUtils.*;
import static org.jsonschema2pojo.rules.PrimitiveTypes.isPrimitive;
import static org.jsonschema2pojo.util.TypeUtil.resolveType;

public class OpenEnumRule implements Rule<JClassContainer, JType> {

    private static final String VALUE_FIELD_NAME = "value";

    private final RuleFactory ruleFactory;

    protected OpenEnumRule(RuleFactory ruleFactory) {
        this.ruleFactory = ruleFactory;
    }

    @Override
    public JType apply(String nodeName, JsonNode node, JsonNode parent, JClassContainer container, Schema schema) {

        JDefinedClass _enum;
        try {
            _enum = createEnum(node, nodeName, container);
        } catch (ClassAlreadyExistsException e) {
            return e.getExistingClass();
        }

        schema.setJavaTypeIfEmpty(_enum);

        if (node.has("javaInterfaces")) {
            addInterfaces(_enum, node.get("javaInterfaces"));
        }

        // copy our node; remove the javaType as it will throw off the TypeRule for our case
        ObjectNode typeNode = node.deepCopy();
        typeNode.remove("javaType");

        // If type is specified on the enum, get a type rule for it.  Otherwise, we're a string.
        // (This is different from the default of Object, which is why we don't do this for every case.)
        JType backingType = node.has("type") ?
                ruleFactory.getTypeRule().apply(nodeName, typeNode, parent, container, schema) :
                container.owner().ref(String.class);

        JMethod factoryMethod = addFactoryMethod(_enum, backingType);
        List<JFieldVar> enumConstants = addEnumConstants(node.path("enum"), _enum, node.path("javaEnumNames"), backingType, factoryMethod);
        addConstantDeclaredValues(_enum, enumConstants);
        JFieldVar valueField = addValueField(_enum, backingType);
        addToString(_enum, valueField);
        addMethodIsDeclaredValue(_enum);
        return _enum;
    }

    private JDefinedClass createEnum(JsonNode node, String nodeName, JClassContainer container) throws ClassAlreadyExistsException {

        try {
            if (node.has("javaType")) {
                String fqn = node.get("javaType").asText();

                if (isPrimitive(fqn, container.owner())) {
                    throw new GenerationException("Primitive type '" + fqn + "' cannot be used as an enum.");
                }

                try {
                    Class<?> existingClass = Thread.currentThread().getContextClassLoader().loadClass(fqn);
                    throw new ClassAlreadyExistsException(container.owner().ref(existingClass));
                } catch (ClassNotFoundException e) {
                    return container.owner()._class(fqn, ClassType.CLASS);
                }
            } else {
                try {
                    return container._class(JMod.PUBLIC, getEnumName(nodeName, node, container), ClassType.CLASS);
                } catch (JClassAlreadyExistsException e) {
                    throw new GenerationException(e);
                }
            }
        } catch (JClassAlreadyExistsException e) {
            throw new ClassAlreadyExistsException(e.getExistingClass());
        }
    }

    private JMethod addFactoryMethod(JDefinedClass _enum, JType backingType) {
        JFieldVar quickLookupMap = addQuickLookupMap(_enum, backingType);

        JMethod fromString = _enum.method(JMod.PUBLIC | JMod.STATIC, _enum, "fromString");
        JVar valueParam = fromString.param(backingType, "s");

        JBlock body = fromString.body();
        body.add(quickLookupMap.invoke("putIfAbsent")
                .arg(valueParam)
                .arg(JExpr._new(_enum).arg(valueParam)));
        body._return(quickLookupMap
                .invoke("get")
                .arg(valueParam));

        ruleFactory.getAnnotator().enumCreatorMethod(_enum, fromString);

        return fromString;
    }

    private JFieldVar addQuickLookupMap(JDefinedClass _enum, JType backingType) {

        JClass lookupType = _enum.owner().ref(Map.class).narrow(backingType.boxify(), _enum);
        JFieldVar lookupMap = _enum.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, lookupType, "values");

        JClass lookupImplType = _enum.owner().ref(HashMap.class).narrow(backingType.boxify(), _enum);
        lookupMap.init(JExpr._new(lookupImplType));

        return lookupMap;
    }

    private JFieldVar addValueField(JDefinedClass _enum, JType type) {
        JFieldVar valueField = _enum.field(JMod.PRIVATE, type, VALUE_FIELD_NAME);

        JMethod constructor = _enum.constructor(JMod.PRIVATE);
        JVar valueParam = constructor.param(type, VALUE_FIELD_NAME);
        JBlock body = constructor.body();
        body.assign(JExpr._this().ref(valueField), valueParam);

        return valueField;
    }

    private void addToString(JDefinedClass _enum, JFieldVar valueField) {
        JMethod toString = _enum.method(JMod.PUBLIC, String.class, "toString");
        JBlock body = toString.body();

        JExpression toReturn = JExpr._this().ref(valueField);
        if(!isString(valueField.type())){
            toReturn = toReturn.plus(JExpr.lit(""));
        }

        body._return(toReturn);

        toString.annotate(Override.class);
        ruleFactory.getAnnotator().enumValueMethod(_enum, toString);
    }

    private boolean isString(JType type){
        return type.fullName().equals(String.class.getName());
    }

    private List<JFieldVar> addEnumConstants(JsonNode node, JDefinedClass _enum, JsonNode customNames, JType type, JMethod factoryMethod) {
        Collection<String> existingConstantNames = new ArrayList<>();
        List<JFieldVar> enumConstants = new ArrayList<>();
        for (int i = 0; i < node.size(); i++) {
            JsonNode value = node.path(i);

            if (!value.isNull()) {
                String constantName = getConstantName(value.asText(), customNames.path(i).asText());
                constantName = makeUnique(constantName, existingConstantNames);
                existingConstantNames.add(constantName);

                JFieldVar constant = _enum.field(JMod.PUBLIC | JMod.STATIC | JMod.FINAL, _enum, constantName);

                constant.init(_enum.staticInvoke(factoryMethod).arg(JExpr.lit(value.asText())));
                enumConstants.add(constant);
            }
        }
        return enumConstants;
    }

    /**
     * Adds new constant declaredValues, which is a Set containing all enum value constants
     * (i.e.: all enum values known at compile time).
     *
     * @param enumClass
     * @param enumConstants
     */
    private void addConstantDeclaredValues(JDefinedClass enumClass, List<JFieldVar> enumConstants) {
        JClass fieldType = enumClass.owner().ref(Set.class).narrow(enumClass);
        JFieldVar field = enumClass.field(JMod.PUBLIC | JMod.STATIC | JMod.FINAL, fieldType, "declaredValues");
        JClass fieldConcreteType = enumClass.owner().ref(HashSet.class).narrow(enumClass);

        JInvocation arraysAsListInvocation = enumClass.owner().ref(Arrays.class).staticInvoke("asList");
        // Add enum constants to the asListInvocation
        for (JFieldVar constant : enumConstants) {
            arraysAsListInvocation.arg(enumClass.staticRef(constant));
        }

        // construct HashSet using Arrays.asList()
        JInvocation hashSetConstructorInvocation = JExpr._new(fieldConcreteType).arg(arraysAsListInvocation);

        // wrap HashSet into UnmodifiableSet
        JInvocation unmodifiableSetInvocation = enumClass.owner().ref(Collections.class).staticInvoke("unmodifiableSet").arg(hashSetConstructorInvocation);

        // Initialize the field to unmodifiable set
        field.init(unmodifiableSetInvocation);

        field.javadoc().add("Set containing all enum values declared at compile time.");
        field.javadoc().add(" Use it in your application to iterate over declared values.");
    }

    private void addMethodIsDeclaredValue(JDefinedClass _enum) {
        JMethod method = _enum.method(JMod.PUBLIC, Boolean.class, "isDeclaredValue");
        JExpression toReturn = _enum.staticRef("declaredValues").invoke("contains").arg(JExpr._this());
        method.body()._return(toReturn);

        method.javadoc().add("returns true if this enum is part of the declared values.");
        method.javadoc().add(" Use it in your application to detect when values coming from outside of the app are not yet part of the declared values (i.e.: there is a new version of the enum that your application is not yet aware of.");
    }

    private String getEnumName(String nodeName, JsonNode node, JClassContainer container) {
        String fieldName = ruleFactory.getNameHelper().getClassName(nodeName, node);
        String className = ruleFactory.getNameHelper().replaceIllegalCharacters(capitalize(fieldName));
        String normalizedName = ruleFactory.getNameHelper().normalizeName(className);

        Collection<String> existingClassNames = new ArrayList<>();
        for (Iterator<JDefinedClass> classes = container.classes(); classes.hasNext();) {
            existingClassNames.add(classes.next().name());
        }
        return makeUnique(normalizedName, existingClassNames);
    }

    private String makeUnique(String name, Collection<String> existingNames) {
        boolean found = false;
        for (String existingName : existingNames) {
            if (name.equalsIgnoreCase(existingName)) {
                found = true;
                break;
            }
        }
        if (found) {
            name = makeUnique(name + "_", existingNames);
        }
        return name;
    }

    protected String getConstantName(String nodeName, String customName) {
        if (isNotBlank(customName)) {
            return customName;
        }

        List<String> enumNameGroups = new ArrayList<>(asList(splitByCharacterTypeCamelCase(nodeName)));

        String enumName = "";
        for (Iterator<String> iter = enumNameGroups.iterator(); iter.hasNext();) {
            if (containsOnly(ruleFactory.getNameHelper().replaceIllegalCharacters(iter.next()), "_")) {
                iter.remove();
            }
        }

        enumName = upperCase(join(enumNameGroups, "_"));

        if (isEmpty(enumName)) {
            enumName = "__EMPTY__";
        } else if (Character.isDigit(enumName.charAt(0))) {
            enumName = "_" + enumName;
        }

        return enumName;
    }

    private void addInterfaces(JDefinedClass jclass, JsonNode javaInterfaces) {
        for (JsonNode i : javaInterfaces) {
            jclass._implements(resolveType(jclass._package(), i.asText()));
        }
    }

}